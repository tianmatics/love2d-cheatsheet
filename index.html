<!DOCTYPE html>

<html lang="en">

<head>

    <meta charset="UTF-8">

    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <title>LÖVE 11.5 Interactive Cheatsheet</title>

    <script src="https://cdn.tailwindcss.com"></script>

    <!-- Chosen Palette: Warm Neutrals -->

    <!-- Application Structure Plan: A two-column layout. The left column is a fixed, scrollable navigation menu listing all LÖVE modules. The right column is the main content area, which dynamically displays the API details for the module selected from the navigation. A search bar at the top of the navigation filters all API entries in real-time. This structure was chosen because it provides persistent navigation, allowing users to quickly switch between modules, while the dynamic content display and search functionality offer a fast and efficient way to locate specific information, which is the primary goal of a cheatsheet. -->

    <!-- Visualization & Content Choices: The source material is a textual API reference. Goal: Inform/Organize. Method: The data is organized into structured lists within expandable sections. Interaction: Users can click on module names in the navigation to display the relevant content and use a search bar to filter all entries across all modules. Justification: This approach is optimal for text-heavy reference material, prioritizing scannability and quick information retrieval over visual data representation. No charts are necessary. Library/Method: Vanilla JavaScript for DOM manipulation and filtering. -->

    <!-- CONFIRMATION: NO SVG graphics used. NO Mermaid JS used. -->

    <style>

        body {

            background-color: #FDFDFD;

            color: #333;

            font-family: 'Inter', sans-serif;

        }

        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&family=Fira+Code:wght@400;500&display=swap');

        .api-entry {

            transition: all 0.2s ease-in-out;

        }

        .api-code {

            font-family: 'Fira Code', monospace;

            background-color: #F0EFEF;

            border-radius: 0.25rem;

            padding: 0.1rem 0.3rem;

            font-size: 0.9em;

        }

        .nav-link.active {

            background-color: #DDCDB8;

            color: #333;

            font-weight: 600;

        }

        .content-section {

            display: none;

        }

        .content-section.active {

            display: block;

        }

        .hidden-by-search {

            display: none !important;

        }

    </style>

</head>

<body class="antialiased">

    <div class="flex flex-col md:flex-row min-h-screen">

        <!-- Sidebar Navigation -->

        <aside class="w-full md:w-64 lg:w-72 bg-[#F7F3EE] p-4 md:fixed md:h-full md:overflow-y-auto border-r border-gray-200">

            <h1 class="text-2xl font-bold text-[#4A4A4A] mb-4">LÖVE 11.5 API</h1>

            <input type="text" id="searchInput" placeholder="Search API..." class="w-full p-2 mb-4 border rounded-md focus:outline-none focus:ring-2 focus:ring-[#DDCDB8]">

            <nav id="navigation" class="space-y-1">

                <!-- Navigation links will be injected here by JS -->

            </nav>

        </aside>

        <!-- Main Content -->

        <main class="flex-1 md:ml-64 lg:ml-72 p-6 md:p-10">

            <div id="content-container">

                <!-- Content sections will be injected here by JS -->

            </div>

        </main>

    </div>

    <script>

        const apiData = {

            "Callbacks": {

                description: "These are functions that you can define in your code which will be called by LÖVE at specific times.",

                items: [

                    { name: "love.load(args)", desc: "Run once when the game starts." },

                    { name: "love.update(dt)", desc: "Used to update the game's state. `dt` is the time since the last update in seconds." },

                    { name: "love.draw()", desc: "Used to draw to the screen." },

                    { name: "love.quit()", desc: "Run when the game is quit. Return `true` to cancel quitting." },

                    { name: "love.focus(focused)", desc: "Run when the window gains/loses focus." },

                    { name: "love.resize(w, h)", desc: "Run when the window is resized." },

                    { name: "love.mousepressed(x, y, button, isTouch)", desc: "Called when a mouse button is pressed." },

                    { name: "love.mousereleased(x, y, button, isTouch)", desc: "Called when a mouse button is released." },

                    { name: "love.mousemoved(x, y, dx, dy, isTouch)", desc: "Called when the mouse is moved." },

                    { name: "love.wheelmoved(x, y)", desc: "Called when the mouse wheel is scrolled." },

                    { name: "love.keypressed(key, scancode, isRepeat)", desc: "Called when a keyboard key is pressed." },

                    { name: "love.keyreleased(key, scancode)", desc: "Called when a keyboard key is released." },

                    { name: "love.textinput(text)", desc: "Called when text is entered (e.g., from keyboard input)." },

                    { name: "love.joystickadded(joystick)", desc: "Called when a joystick is connected." },

                    { name: "love.joystickremoved(joystick)", desc: "Called when a joystick is disconnected." },

                    { name: "love.joystickpressed(joystick, button)", desc: "Called when a joystick button is pressed." },

                    { name: "love.joystickreleased(joystick, button)", desc: "Called when a joystick button is released." },

                    { name: "love.joystickaxis(joystick, axis, value)", desc: "Called when a joystick axis moves." },

                    { name: "love.joystickhat(joystick, hat, direction)", desc: "Called when a joystick hat moves." },

                    { name: "love.lowmemory()", desc: "Called when the system is running low on memory." },

                    { name: "love.threaderror(thread, errorstr)", desc: "Called when a thread encounters an error." },

                ]

            },

            "love.graphics": {

                description: "The love.graphics module is used for all drawing and screen-related things.",

                subsections: {

                    "Drawing": [

                        { name: "love.graphics.draw(drawable, x, y, r, sx, sy, ox, oy, kx, ky)", desc: "Draws a drawable object." },

                        { name: "love.graphics.draw(drawable, transform)", desc: "Draws a drawable object using a Transform object." },

                        { name: "love.graphics.printf(text, x, y, limit, align, r, sx, sy, ox, oy, kx, ky)", desc: "Prints formatted text." },

                        { name: "love.graphics.print(text, x, y, r, sx, sy, ox, oy, kx, ky)", desc: "Prints text." },

                        { name: "love.graphics.circle(mode, x, y, radius, segments)", desc: "Draws a circle." },

                        { name: "love.graphics.ellipse(mode, x, y, a, b, segments)", desc: "Draws an ellipse." },

                        { name: "love.graphics.line(x1, y1, x2, y2, ...)", desc: "Draws lines." },

                        { name: "love.graphics.point(x, y)", desc: "Draws a point." },

                        { name: "love.graphics.polygon(mode, x1, y1, x2, y2, ...)", desc: "Draws a polygon." },

                        { name: "love.graphics.rectangle(mode, x, y, width, height)", desc: "Draws a rectangle." },

                        { name: "love.graphics.triangle(mode, x1, y1, x2, y2, x3, y3)", desc: "Draws a triangle." },

                    ],

                    "Transformations": [

                        { name: "love.graphics.push()", desc: "Pushes the current transformation state onto a stack." },

                        { name: "love.graphics.pop()", desc: "Pops a transformation state from the stack." },

                        { name: "love.graphics.translate(dx, dy)", desc: "Translates the coordinate system." },

                        { name: "love.graphics.rotate(angle)", desc: "Rotates the coordinate system." },

                        { name: "love.graphics.scale(sx, sy)", desc: "Scales the coordinate system." },

                        { name: "love.graphics.shear(kx, ky)", desc: "Shears the coordinate system." },

                    ],

                    "Getters/Setters": [

                        { name: "love.graphics.getBackgroundColor()", desc: "Returns the background color." },

                        { name: "love.graphics.setBackgroundColor(r, g, b, a)", desc: "Sets the background color." },

                        { name: "love.graphics.getColor()", desc: "Returns the current drawing color." },

                        { name: "love.graphics.setColor(r, g, b, a)", desc: "Sets the current drawing color." },

                        { name: "love.graphics.getCanvas()", desc: "Returns the current Canvas." },

                        { name: "love.graphics.setCanvas(canvas, ...)", desc: "Sets one or more Canvases for rendering." },

                        { name: "love.graphics.getFont()", desc: "Returns the current Font." },

                        { name: "love.graphics.setFont(font)", desc: "Sets the current Font." },

                        { name: "love.graphics.getDimensions()", desc: "Returns the width and height of the window." },

                        { name: "love.graphics.newImage(filename)", desc: "Creates a new Image." },

                        { name: "love.graphics.newFont(filename, size)", desc: "Creates a new Font from a file." },

                        { name: "love.graphics.newQuad(x, y, width, height, sw, sh)", desc: "Creates a new Quad." },

                        { name: "love.graphics.newShader(code)", desc: "Creates a new Shader from code." },

                        { name: "love.graphics.newSpriteBatch(image, size)", desc: "Creates a new SpriteBatch." },

                        { name: "love.graphics.newCanvas(width, height, settings)", desc: "Creates a new Canvas." },

                        { name: "love.graphics.newMesh(vertices, mode, usage)", desc: "Creates a new Mesh." },

                        { name: "love.graphics.newText(font, text)", desc: "Creates a new Text object." },

                        { name: "love.graphics.newParticleSystem(image, buffer)", desc: "Creates a new ParticleSystem." },

                        { name: "love.graphics.newTransform()", desc: "Creates a new Transform object." },

                    ],

                    "Enums": [

                        { name: "BlendMode", desc: "`alpha`, `additive`, `subtractive`, `multiplicative`, `premultiplied`, `replace`." },

                        { name: "DrawMode", desc: "`fill`, `line`." },

                        { name: "FilterMode", desc: "`linear`, `nearest`." },

                        { name: "LineStyle", desc: "`rough`, `smooth`." },

                        { name: "PointStyle", desc: "`rough`, `smooth`." },

                        { name: "WrapMode", desc: "`clamp`, `repeat`, `mirroredrepeat`." },

                        { name: "AlignMode", desc: "`left`, `center`, `right`, `justify`." },

                    ]

                }

            },

            "love.audio": {

                description: "Provides an interface to the user's sound card. It can be used to play sound effects and music.",

                subsections: {

                    "Functions": [

                        { name: "love.audio.play(source)", desc: "Plays a Source." },

                        { name: "love.audio.pause(source)", desc: "Pauses a Source." },

                        { name: "love.audio.stop(source)", desc: "Stops a Source." },

                        { name: "love.audio.setVolume(volume)", desc: "Sets the master volume." },

                        { name: "love.audio.getVolume()", desc: "Returns the master volume." },

                        { name: "love.audio.newSource(file, type)", desc: "Creates a new Source from a file." },

                    ],

                    "Class `Source`": [

                        { name: "Source:play()", desc: "Plays the Source." },

                        { name: "Source:pause()", desc: "Pauses the Source." },

                        { name: "Source:stop()", desc: "Stops the Source." },

                        { name: "Source:rewind()", desc: "Rewinds the Source." },

                        { name: "Source:isLooping()", desc: "Checks if the Source is looping." },

                        { name: "Source:setLooping(loop)", desc: "Sets whether the Source loops." },

                        { name: "Source:getPitch()", desc: "Returns the pitch of the Source." },

                        { name: "Source:setPitch(pitch)", desc: "Sets the pitch of the Source." },

                        { name: "Source:getVolume()", desc: "Returns the volume of the Source." },

                        { name: "Source:setVolume(volume)", desc: "Sets the volume of the Source." },

                    ],

                    "Enums": [

                        { name: "SourceType", desc: "`static`, `stream`." },

                        { name: "DistanceModel", desc: "`none`, `inverse`, `inverseclamped`, `linear`, `linearclamped`, `exponent`, `exponentclamped`." },

                    ]

                }

            },

            "love.timer": {

                description: "The timer module provides functions to get the time, and to sleep the program for a certain amount of time.",

                 items: [

                    { name: "love.timer.getDelta()", desc: "Returns the time since the last frame." },

                    { name: "love.timer.getFPS()", desc: "Returns the current frames per second." },

                    { name: "love.timer.getMicroTime()", desc: "Returns the current time in microseconds." },

                    { name: "love.timer.getSleep()", desc: "Returns the amount of time LÖVE will sleep." },

                    { name: "love.timer.getTime()", desc: "Returns the current time in seconds." },

                    { name: "love.timer.getAverageDelta()", desc: "Returns the average time since the last frame." },

                    { name: "love.timer.setSleep(s)", desc: "Sets the amount of time LÖVE will sleep." },

                    { name: "love.timer.step()", desc: "Updates the timer." },

                 ]

            },

            "love.filesystem": {

                description: "The love.filesystem module provides access to the user's filesystem.",

                subsections: {

                    "Functions": [

                        { name: "love.filesystem.enumerate(dir)", desc: "Returns a list of files and subdirectories in a given path." },

                        { name: "love.filesystem.exists(filename)", desc: "Checks if a file or directory exists." },

                        { name: "love.filesystem.isDirectory(filename)", desc: "Checks if a path is a directory." },

                        { name: "love.filesystem.isFile(filename)", desc: "Checks if a path is a file." },

                        { name: "love.filesystem.lines(filename)", desc: "Returns an iterator for reading lines from a file." },

                        { name: "love.filesystem.load(filename)", desc: "Loads a Lua file." },

                        { name: "love.filesystem.mkdir(name)", desc: "Creates a new directory." },

                        { name: "love.filesystem.read(filename, size)", desc: "Reads the contents of a file." },

                        { name: "love.filesystem.remove(filename)", desc: "Removes a file or empty directory." },

                        { name: "love.filesystem.write(filename, data, size)", desc: "Writes data to a file." },

                        { name: "love.filesystem.append(filename, data, size)", desc: "Appends data to a file." },

                        { name: "love.filesystem.setIdentity(name)", desc: "Sets the save directory name." },

                        { name: "love.filesystem.newFile(filename)", desc: "Creates a new File object." },

                    ],

                    "Class `File`": [

                        { name: "File:close()", desc: "Closes the file." },

                        { name: "File:eof()", desc: "Checks if the end of the file has been reached." },

                        { name: "File:read(bytes)", desc: "Reads data from the file." },

                        { name: "File:write(data)", desc: "Writes data to the file." },

                    ],

                    "Enums": [

                        { name: "FileMode", desc: "`r` (read), `w` (write), `a` (append)." }

                    ]

                }

            },

            "love.keyboard": {

                description: "Provides an interface to the user's keyboard.",

                items: [

                    { name: "love.keyboard.isDown(key1, ...)", desc: "Checks if one or more keys are pressed." },

                    { name: "love.keyboard.setKeyRepeat(delay, interval)", desc: "Sets the key repeat delay and interval." },

                    { name: "love.keyboard.hasKeyRepeat()", desc: "Checks if key repeat is enabled." },

                    { name: "love.keyboard.getScancodeFromKey(key)", desc: "Returns the scancode for a key." },

                    { name: "love.keyboard.getKeyFromScancode(scancode)", desc: "Returns the key for a scancode." },

                    { name: "love.keyboard.setTextInput(enable)", desc: "Enables or disables text input." },

                ]

            },

            "love.mouse": {

                description: "Provides an interface to the user's mouse.",

                subsections: {

                    "Functions": [

                        { name: "love.mouse.getPosition()", desc: "Returns the mouse cursor's position." },

                        { name: "love.mouse.isDown(button1, ...)", desc: "Checks if one or more mouse buttons are pressed." },

                        { name: "love.mouse.isGrabbed()", desc: "Checks if the mouse is grabbed." },

                        { name: "love.mouse.setGrabbed(grab)", desc: "Sets whether the mouse is grabbed." },

                        { name: "love.mouse.isVisible()", desc: "Checks if the mouse cursor is visible." },

                        { name: "love.mouse.setVisible(visible)", desc: "Sets whether the mouse cursor is visible." },

                        { name: "love.mouse.setPosition(x, y)", desc: "Sets the mouse cursor's position." },

                        { name: "love.mouse.setRelativeMode(enable)", desc: "Sets whether the mouse is in relative mode." },

                    ],

                    "Enums": [

                        { name: "MouseConstant", desc: "`l` (left), `m` (middle), `r` (right), `wu` (wheel up), `wd` (wheel down), `x1`, `x2`." },

                        { name: "SystemCursor", desc: "`arrow`, `ibeam`, `wait`, `waitarrow`, `hand`, `sizehoriz`, `sizevert`, `sizeall`, `nodrop`." },

                    ]

                }

            },

            "love.joystick": {

                description: "Provides an interface to connected joysticks.",

                subsections: {

                    "Functions": [

                        { name: "love.joystick.getJoysticks()", desc: "Returns a list of connected Joysticks." },

                        { name: "love.joystick.getJoystickCount()", desc: "Returns the number of connected Joysticks." },

                    ],

                    "Class `Joystick`": [

                        { name: "Joystick:getName()", desc: "Returns the Joystick's name." },

                        { name: "Joystick:setVibration(left, right, duration)", desc: "Sets the vibration motor speeds." },

                        { name: "Joystick:getAxis(axis)", desc: "Returns the value of an axis." },

                        { name: "Joystick:getButton(button)", desc: "Checks if a button is pressed." },

                        { name: "Joystick:isGamepad()", desc: "Checks if the Joystick is a gamepad." },

                    ],

                    "Enums": [

                        { name: "JoystickConstant", desc: "`c` (centered), `d` (down), `l` (left), `u` (up), `r` (right)." },

                        { name: "GamepadAxis", desc: "`leftx`, `lefty`, `rightx`, `righty`, `triggerleft`, `triggerright`." },

                        { name: "GamepadButton", desc: "`a`, `b`, `x`, `y`, `back`, `guide`, `start`, `leftstick`, `rightstick`, `leftshoulder`, `rightshoulder`, `dpup`, `dpdown`, `dpleft`, `dpright`." },

                    ]

                }

            },

        };

        document.addEventListener('DOMContentLoaded', () => {

            const navigation = document.getElementById('navigation');

            const contentContainer = document.getElementById('content-container');

            const searchInput = document.getElementById('searchInput');

            function createApiEntry(item) {

                return `

                    <div class="api-entry mb-4">

                        <p class="api-code text-md font-medium">${item.name}</p>

                        <p class="text-gray-600 ml-2">${item.desc}</p>

                    </div>

                `;

            }

            // Populate navigation and content

            Object.keys(apiData).forEach((key, index) => {

                const sectionData = apiData[key];

                const sectionId = key.replace(/\./g, '-');

                // Navigation link

                const navLink = document.createElement('a');

                navLink.href = `#${sectionId}`;

                navLink.textContent = key;

                navLink.className = 'nav-link block p-2 rounded-md hover:bg-[#EAE1D6] transition-colors duration-200';

                if (index === 0) {

                    navLink.classList.add('active');

                }

                navigation.appendChild(navLink);

                // Content section

                const contentSection = document.createElement('div');

                contentSection.id = sectionId;

                contentSection.className = 'content-section';

                if (index === 0) {

                    contentSection.classList.add('active');

                }

                let contentHtml = `<h2 class="text-3xl font-bold mb-2 text-[#4A4A4A]">${key}</h2>`;

                if (sectionData.description) {

                    contentHtml += `<p class="text-lg text-gray-700 mb-8">${sectionData.description}</p>`;

                }

                if (sectionData.items) {

                    contentHtml += sectionData.items.map(createApiEntry).join('');

                }

                if (sectionData.subsections) {

                    Object.keys(sectionData.subsections).forEach(subKey => {

                        contentHtml += `<h3 class="text-2xl font-semibold mt-8 mb-4 border-b pb-2">${subKey}</h3>`;

                        contentHtml += sectionData.subsections[subKey].map(createApiEntry).join('');

                    });

                }

                contentSection.innerHTML = contentHtml;

                contentContainer.appendChild(contentSection);

            });

            // Navigation logic

            const navLinks = document.querySelectorAll('.nav-link');

            const contentSections = document.querySelectorAll('.content-section');

            navLinks.forEach(link => {

                link.addEventListener('click', (e) => {

                    e.preventDefault();

                    const targetId = link.getAttribute('href').substring(1);

                    navLinks.forEach(l => l.classList.remove('active'));

                    link.classList.add('active');

                    contentSections.forEach(section => {

                        section.classList.remove('active');

                        if (section.id === targetId) {

                            section.classList.add('active');

                        }

                    });

                    window.scrollTo(0, 0);

                });

            });

            // Search logic

            searchInput.addEventListener('input', (e) => {

                const searchTerm = e.target.value.toLowerCase();

                const allApiEntries = document.querySelectorAll('.api-entry');

                allApiEntries.forEach(entry => {

                    const entryText = entry.textContent.toLowerCase();

                    if (entryText.includes(searchTerm)) {

                        entry.classList.remove('hidden-by-search');

                    } else {

                        entry.classList.add('hidden-by-search');

                    }

                });

            });

        });

    </script>

</body>

</html>
